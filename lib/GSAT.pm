package GSAT;

#参考circos布局

#功能分成graphfilt,graphmap,graphcorr,graphsimply等选项，不可联用；pipe分成graph-short，graph-long，graph-sim，graph-corr等选项即可，可联用。功能与pipeline不可同时设定
#支持参数放进config文件里；功能中config文件为可选项；pipeline要求必须有config文件。
#统一放入文件夹中。此外，不同pipeline放入不同子文件夹。

=pod

=head1 NAME

GSAT - Graph-based Sequence Assembly Toolkit

=head1 SYNOPSIS

    gsat <command> [options]

    Commands:
    -- Functions
       graphFilt            filter the assembly graph with different params
       graphMap             conduct graph mapping to detect mapped paths in a graph for query sequence
       graphCorr            correct the sequences in a graph by using long reads. HIFI reads is recommanded.
       graphSimplify        simplify the graph based on supported mapped paths of long reads.
       rmOverlap            remove the overlaping regions from a graph

    -- Pipelines
       graphShort           generate a Organelle Graph from a raw graph of de novo assembly
       graphLong            generate a Mitochondrial Rough Graph from a OG
       graphSimplification  generate a Mitochondrial Rough Master Graph from a MRG
       graphCorrection      generate a Mitochondrial Master Graph from a MRMG

    -- Information
       help                 print a brief help information
       man                  print a complete help document
       version              print the version information

=head1 VERSION

GSAT version 1.00 (2022-07-14)

=head1 USAGE

 Usage

=head1 graphFilt

    Usage:   gsat graphFilt [options]

    Global params:
    -pt|-p             filter the plastid-specific contigs. Not compatiable with -nuc.*
    -nuc|-n            filter the nuclear-specific contigs. Not compatiable with -pt.*
    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of the output files.

    Pt-filtering params:
    -mapFile [str]     the mapped paths file generated by graph mapping.*
    -minPathNo [int]   the min number of supported paths for remaining a link.*
    -minEnd [int]      the end contig with a length shorter than this value will be filtered.*
    -rmBubbPt          remove the pt-like contig from a bubble. Be careful with this option. [off]

    Nuc-filtering params:
    -minDep1 [int]     the min depth allowed for a remained contig longer than 500bp.*
    -minDep2 [int]     the min depth allowed for a remained contig longer than 1000bp.*
    -rmSep             remove the seperate ctg with no link to others or not. [off]

    Note: the * denoted a required option. 

=head1 graphMap

    Usage:   gsat graphMap [options]

    -align|-a                 Conduct graph mapping of reads vs the graph (require -r and -g options). [off]*
    -readFile|-r [str]        A Pacbio / Nanopore read file in fasta format. NOT available if -a is off.*
    -gfaFile|-g [str]         The input graph file.*
    -blast7File|-b [str]      Calculate the mapped paths from a blastn result file. NOT available if -a|-p is applied.*
    -pafFile|-p [str]         Calculate the mapped paths from a minimap2 result file. NOT available if -a|-b is applied.*
    -minRead [int]            The min length (bp) of selected reads. [1000]
    -maxOffset1 [int]         The max offset between the ends of contigs in alignments, regarding the overlaps of contigs. [10]
                              The real range of offset is from 1-K-offset to 1-K+offset. Not compatible with --maxOffset2.
    -maxOffset2 [int]         The max offset between the ends of contigs in alignments, ignoring the overlaps of contigs. [off]
                              The real range of offset is from 0-offset to 0+offset. Not compatible with --maxOffset1.
    -maxCombDis [int]         The max distances allowed for combining two alignments. [15]
    -maxEdgeSize1 [int]       The max gap size allowed for the alignment at the edge of reads. [60]
    -maxEdgeSize2 [int]       The max gap size allowed for the alignment at the edge of contigs. [10]
    -maxBounderRatio [float]  The max ratio allowed for the bounder size which covered the full length of a contig. [0.1]
    -maxIdenGap [float]       The max difference allowed for remained an alternative alignment (path)
                              when compared with to the identity of the best alignment (path). [1]
                              Caution: It is still a beta method that is not recommanded to use until now.
    -minIden [float]          The min identity allowed for use an alignment (in b7 and paf file). [0.85]
    -minCovofRead [float]     The min coverage allowed in the alignment for use a read (in b7 and paf file). [0.9]
    -minCovbyPath [float]     The min coverage to the read allowed for outputting a path. [0.9]
    -out|-o [str]             The name prefix of output files.
    -strictBub                Bubbles were retained only when all members were mapped to the read with exactly the same
                              start and end positions. [on]
    -depth|-d                 Calculate the depth of passed reads on the contigs. [off]
    -calDepth|-cd             Calculate the depth (like -d) directly from previous results (require -o and -g options). [off]
    -filterPaths|-f           Further filtering the previous results when apply the -cd option. [off]
                              However, only -minRead and -minCovbyPath options are available for now.
    -minimap2 [str]           Use minimap2 to map reads to the long contigs, rather than use blastn. [off]
                              The read type should be specified here such as hifi, clr, ont.

    Note: the * denoted a required option. 

=head1 graphCorr

    Usage:   gsat graphCorr [options]

    -readFile|-r [str]       A Pacbio / Nanopore read file in fasta format.* 
    -gfaFile|-g  [str]       The file of genome assembly in gfa format.\n";*
    -pathFile|-p [str]       The mapped paths file generated by GraphMap module (module version >= 1.51).*
    -minReadProp|-m [float]  The min proportion of supported reads to confirm a base correction.
    -out|-o [str]            The name prefix of output files.\n";

    Note: the * denoted a required option.

=head1 graphSimplify

    Usage:   gsat graphSimplify [options]

    -gfaFile|-g [str]  the input graph file.*
    -mapFile [str]     the mapped paths file generated by graph mapping.*
    -minPathNo [int]   the min number of supported paths for remaining a link.*
    -minEnd [int]      the end contig with a length shorter than this value will be filtered.
    -out|-o [str]      the name prefix of output files.\n";

    Note: the * denoted a required option.

=head1 rmOverlap

    Usage:   gsat rmOverlap [options]

    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of output files.\n";

    Note: the * denoted a required option.

=cut

use strict;
use warnings;
use FindBin;
use File::Basename;
use Getopt::Long;
use Getopt::Long qw(GetOptionsFromArray);
use Pod::Usage;
use Pod::Find qw(pod_where);
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../lib";
use lib "$FindBin::RealBin/lib";

require GSAT::graphFilterPt;
require GSAT::graphFilterNuc;
require GSAT::graphMapper;
require GSAT::graphCorrector;
require GSAT::graphSimply;
require GSAT::rmOverlap;

sub gsatRun{
   our ($proc,$opt)=@_;
   if($proc =~ /^graphFilt$/i){
      my ($pt,$nuc,$gfa,$map,$outP,$minPath,$minEnd,$rmPt,$minD1,$minD2,$rmSep);
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphFilt) ])if @{$opt} == 0;
      GetOptionsFromArray($opt,
        'pt'           => \$pt,
        'nuc'          => \$nuc,
        'gfaFile=s'    => \$gfa,
        'mapFile=s'    => \$map,
        'out=s'        => \$outP,
        'minPathNo=i'  => \$minPath,
        'minEnd=i'     => \$minEnd,
        'rmBubbPt'     => \$rmPt,
        'minDep1=i'    => \$minD1,
        'minDep2=i'    => \$minD2,
        'rmSep'        => \$rmSep,
      );
      my $rstat= defined($rmPt) ? 'T':'F';
      graphFilterPt::filterPt($gfa,$map,$minPath,$minEnd,$rstat,'T',$outP) if defined($pt);
      my $rsstat= defined($rmSep) ? 'T':'F';
      graphFilterNuc::filterNuc($gfa,$minD1,$minD2,$rsstat,$outP) if defined($nuc);
   }
   elsif($proc =~ /^graphMap$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphMap) ])if @{$opt} == 0;
      graphMapper::gmap($opt);#done
   }
   elsif($proc =~ /^graphCorr$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphCorr) ])if @{$opt} == 0;
      graphCorrector::grapCorr($opt);#done
   }
   elsif($proc =~ /^graphSimplify$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphSimplify) ])if @{$opt} == 0;
      my ($gfa,$map,$outP,$minPath,$minEnd);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'mapFile=s'      => \$map,
        'out=s'          => \$outP,
        'minPathNo=i'    => \$minPath,
        'minEnd=i'       => \$minEnd,
      );
      graphSimply::filterGraph($gfa,$map,$minPath,$minEnd,$outP);#list
   }
   elsif($proc =~ /^rmOverlap$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(rmOverlap) ])if @{$opt} == 0;
      my ($gfa,$outP);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'out=s'          => \$outP,
      );
      rmOverlap::m0proc($gfa,$outP);#done
   }
   elsif($proc =~ /^graphShort$/i){
      pipeShort($opt);
   }
   elsif($proc =~ /^graphLhort$/i){
      pipeLong($opt);
   }
   elsif($proc =~ /^graphSimplification$/i){
      pipeSim($opt);
   }
   elsif($proc =~ /^graphCorrection$/i){
      pipeCorr($opt);
   }
   else{
      die"Error: Wrong command detected!\n";
   }
}

sub pipeShort{
   ;
}

sub pipeLong{
   ;
}

sub pipeCorr{
   ;
}

sub pipeSim{
   ;
}